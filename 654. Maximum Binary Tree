class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {

        //if no value present means done for that branch return nullptr
        if(nums.size()==0) return nullptr;

        //finding current largest element to add as node
        int currMax = *max_element(nums.begin(),nums.end());
        TreeNode* root = new TreeNode(currMax);

        //fnding index of current max to create prefix and suffix
        int currMaxIdx = -1;
        for(int i=0; i<nums.size(); i++){
            if(nums[i]==currMax){
                currMaxIdx = i;
                break;
            }
        }

        //create suffix prefix 
        vector<int> prefix(nums.begin(),nums.begin()+currMaxIdx);
        vector<int> suffix(nums.begin()+currMaxIdx+1,nums.end());

        //passing prefix for left side node and suffix for right side
        root->left = constructMaximumBinaryTree(prefix);
        root->right = constructMaximumBinaryTree(suffix);

        //return root
        return root;
    }
};
